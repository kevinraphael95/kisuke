# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# ğŸ“Œ kawashima_games.py â€” Mini-jeux Professeur Kawashima
# Objectif : Contient tous les mini-jeux cÃ©rÃ©braux dÃ©tectÃ©s automatiquement
# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# ğŸ“¦ Imports nÃ©cessaires
# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
import random
import asyncio
import discord
from discord.ui import View, Button

# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# ğŸ“¦ ParamÃ¨tres
# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
TIMEOUT = 60  # 1 minute pour rÃ©pondre Ã  chaque mini-jeu

# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# ğŸ”¹ Mini-jeux (chacun avec .emoji et .title)
# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# ğŸ”¹ ğŸ§® Addition Ã  la suite
# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
async def addition_cachee(ctx, embed, get_user_id, bot):
    additions = [random.randint(-9, 9) for _ in range(6)]
    total = sum(additions)

    embed.clear_fields()
    embed.add_field(name="ğŸ§® Additions Ã  la suite", value="Observe bien les additions successives...", inline=False)
    await ctx.edit(embed=embed)
    await asyncio.sleep(3)  # prep_time

    for add in additions:
        embed.clear_fields()
        embed.add_field(name="ğŸ§® Additions Ã  la suite", value=f"{add:+d}", inline=False)
        await ctx.edit(embed=embed)
        await asyncio.sleep(1.8)

    embed.clear_fields()
    embed.add_field(name="ğŸ§® Additions Ã  la suite", value="Quel est le total final ?", inline=False)
    await ctx.edit(embed=embed)

    try:
        msg = await bot.wait_for("message", check=lambda m: m.author.id == get_user_id(), timeout=TIMEOUT)
        return int(msg.content) == total
    except:
        return False

addition_cachee.title = "Addition Ã  la suite"
addition_cachee.emoji = "â•"
addition_cachee.prep_time = 3 + 1.8 * 6  # temps total avant question

# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# ğŸ”¹ ğŸ§® Calcul rapide
# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
async def calcul_rapide(ctx, embed, get_user_id, bot):
    op = random.choice(["+", "-", "*", "/"])
    if op == "*":
        a, b = random.randint(1, 10), random.randint(1, 10)
        answer = a * b
    elif op == "/":
        b = random.randint(1, 10)
        answer = random.randint(1, 10)
        a = b * answer
    else:
        a, b = random.randint(10, 50), random.randint(10, 50)
        answer = eval(f"{a}{op}{b}")

    embed.clear_fields()
    embed.add_field(name="ğŸ§® Calcul rapide", value=f"{a} {op} {b} = ?", inline=False)
    await ctx.edit(embed=embed)

    try:
        msg = await bot.wait_for("message", check=lambda m: m.author.id == get_user_id(), timeout=TIMEOUT)
        return int(msg.content) == answer
    except:
        return False

calcul_rapide.title = "Calcul rapide"
calcul_rapide.emoji = "ğŸ§®"
calcul_rapide.prep_time = 0

# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# ğŸ”¹ ğŸ”¢ CarrÃ© magique 3x3 fiable emoji
# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
async def carre_magique_fiable_emoji(ctx, embed, get_user_id, bot):
    base = [
        [8, 1, 6],
        [3, 5, 7],
        [4, 9, 2]
    ]

    def rotate(square):
        return [list(x) for x in zip(*square[::-1])]

    def flip(square):
        return [row[::-1] for row in square]

    for _ in range(random.randint(0, 3)):
        base = rotate(base)
    if random.choice([True, False]):
        base = flip(base)

    row, col = random.randint(0, 2), random.randint(0, 2)
    answer = base[row][col]
    base[row][col] = "â“"

    num_to_emoji = {i: f"{i}\u20e3" for i in range(1, 10)}

    display = "\n".join("|".join(num_to_emoji.get(x, x) for x in r) for r in base)

    embed.clear_fields()
    embed.add_field(
        name="ğŸ”¢ CarrÃ© magique",
        value=f"ComplÃ¨te le carrÃ© magique pour que toutes les lignes, colonnes et diagonales fassent 15 :\n{display}",
        inline=False
    )
    await ctx.edit(embed=embed)

    try:
        msg = await bot.wait_for("message", check=lambda m: m.author.id == get_user_id(), timeout=TIMEOUT)
        return int(msg.content) == answer
    except:
        return False

carre_magique_fiable_emoji.title = "CarrÃ© magique 3x3"
carre_magique_fiable_emoji.emoji = "ğŸ”¢"
carre_magique_fiable_emoji.prep_time = 0

# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# ğŸ”¹ ğŸ‘€ Compter les emojis
# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
async def compter_emojis(ctx, embed, get_user_id, bot):
    import random

    emojis = ["ğŸ", "ğŸŒ", "ğŸ’", "ğŸ‡", "ğŸŠ"]
    cible = random.choice(emojis)

    # GÃ©nÃ¨re une grille 4x4
    grille = [[random.choice(emojis) for _ in range(4)] for _ in range(4)]
    texte_grille = "\n".join("".join(ligne) for ligne in grille)

    # Compte combien de fois l'emoji cible apparaÃ®t
    total = sum(ligne.count(cible) for ligne in grille)

    embed.clear_fields()
    embed.add_field(
        name="ğŸ‘€ Compter les emojis",
        value=f"{texte_grille}\n\nâ¡ï¸ Combien de {cible} dans cette grille ?",
        inline=False
    )
    await ctx.edit(embed=embed)

    try:
        msg = await bot.wait_for(
            "message",
            check=lambda m: m.author.id == get_user_id(),
            timeout=TIMEOUT
        )
        return msg.content.isdigit() and int(msg.content) == total
    except:
        return False

compter_emojis.title = "Compter les emojis"
compter_emojis.emoji = "ğŸ‘€"
compter_emojis.prep_time = 1.5

# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# ğŸ¨ Couleurs (Stroop complet)
# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
async def couleurs(ctx, embed, get_user_id, bot):
    styles = {
        "bleu": discord.ButtonStyle.primary,
        "vert": discord.ButtonStyle.success,
        "rouge": discord.ButtonStyle.danger,
        "gris": discord.ButtonStyle.secondary
    }

    couleurs_list = list(styles.keys())
    mots = couleurs_list.copy()
    random.shuffle(mots)

    buttons = []
    for couleur, mot in zip(couleurs_list, mots):
        button = Button(label=mot.upper(), style=styles[couleur])
        buttons.append(button)

    question_type = random.choice(["mot", "couleur"])
    if question_type == "mot":
        cible = random.choice(mots)
        question = f"Appuie sur le bouton oÃ¹ est Ã©crit le **MOT** `{cible.upper()}` !"
        condition = lambda b: b.label.lower() == cible
    else:
        cible = random.choice(couleurs_list)
        question = f"Appuie sur le bouton de **COULEUR** `{cible.upper()}` !"
        condition = lambda b: b.style == styles[cible]

    view = View(timeout=TIMEOUT)
    for button in buttons:
        async def callback(interaction, b=button):
            if interaction.user.id != get_user_id():
                await interaction.response.send_message("ğŸš« Ce jeu nâ€™est pas pour toi !", ephemeral=True)
                return
            view.value = condition(b)
            view.stop()
            await interaction.response.defer()

        button.callback = callback
        view.add_item(button)

    embed.clear_fields()
    embed.add_field(name="ğŸ¨ Couleurs (Stroop)", value=question, inline=False)
    await ctx.edit(embed=embed, view=view)

    await asyncio.sleep(0.5)  # prep_time
    await view.wait()
    for child in view.children:
        child.disabled = True
    await ctx.edit(view=view)

    return getattr(view, "value", False)

couleurs.title = "Couleurs"
couleurs.emoji = "ğŸ¨"
couleurs.prep_time = 0.5

# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# ğŸ”¹ ğŸ“… Datation
# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
async def datation(ctx, embed, get_user_id, bot):
    import datetime

    today = datetime.date.today()
    delta_days = random.randint(-7, 7)
    date = today + datetime.timedelta(days=delta_days)
    
    jours_fr = {
        "Monday": "lundi",
        "Tuesday": "mardi",
        "Wednesday": "mercredi",
        "Thursday": "jeudi",
        "Friday": "vendredi",
        "Saturday": "samedi",
        "Sunday": "dimanche"
    }
    jour_complet = jours_fr[date.strftime("%A")]
    jour_abr = jour_complet[:3]

    embed.clear_fields()
    embed.add_field(
        name="ğŸ“… Datation",
        value=f"Quel jour de la semaine Ã©tait le {date.day}/{date.month}/{date.year} ?",
        inline=False
    )
    await ctx.edit(embed=embed)

    try:
        msg = await bot.wait_for(
            "message",
            check=lambda m: m.author.id == get_user_id(),
            timeout=TIMEOUT
        )
        reponse = msg.content.lower().strip()
        return reponse == jour_complet or reponse == jour_abr
    except:
        return False

datation.title = "Datation"
datation.emoji = "ğŸ“…"
datation.prep_time = 0

# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# ğŸ”¹ ğŸ§­ Directions opposÃ©es
# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
async def directions_opposees(ctx, embed, get_user_id, bot):
    import random
    from discord import ButtonStyle
    from discord.ui import View, Button

    # FlÃ¨ches et opposÃ©s simples
    arrows = ["â¬†ï¸", "â¬‡ï¸", "â¬…ï¸", "â¡ï¸"]
    opposites = {
        "â¬†ï¸": "â¬‡ï¸",
        "â¬‡ï¸": "â¬†ï¸",
        "â¬…ï¸": "â¡ï¸",
        "â¡ï¸": "â¬…ï¸"
    }

    # Choix alÃ©atoire de la flÃ¨che
    arrow = random.choice(arrows)
    correct = opposites[arrow]

    # Affichage de la consigne
    embed.clear_fields()
    embed.add_field(
        name="ğŸ§­ Directions opposÃ©es",
        value=f"FlÃ¨che affichÃ©e : {arrow}\nâ¡ï¸ Clique sur **la direction opposÃ©e** le plus vite possible !",
        inline=False
    )
    await ctx.edit(embed=embed)

    # Vue avec les boutons
    view = View(timeout=TIMEOUT)
    for symbol in arrows:
        async def button_callback(interaction, s=symbol):
            if interaction.user.id != get_user_id():
                return
            view.stop()
            view.result = (s == correct)
            await interaction.response.defer()

        btn = Button(label=symbol, style=ButtonStyle.secondary)
        btn.callback = button_callback
        view.add_item(btn)

    msg = await ctx.send(view=view)
    await view.wait()
    await msg.edit(view=None)
    return getattr(view, "result", False)

directions_opposees.title = "Directions opposÃ©es"
directions_opposees.emoji = "ğŸ§­"
directions_opposees.prep_time = 1

# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# ğŸ”¹ â— Ã‰quation Ã  trou
# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
async def equation_trou(ctx, embed, get_user_id, bot):
    op = random.choice(["+", "-", "*"])
    if op == "+":
        a, b = random.randint(1, 20), random.randint(1, 20)
        answer = random.choice([a, b])
        question = f"? + {b} = {a + b}" if answer == a else f"{a} + ? = {a + b}"
    elif op == "-":
        a, b = random.randint(10, 30), random.randint(1, 10)
        answer = random.choice([a, b])
        question = f"? - {b} = {a - b}" if answer == a else f"{a} - ? = {a - b}"
    else:
        a, b = random.randint(1, 10), random.randint(1, 10)
        answer = random.choice([a, b])
        question = f"? Ã— {b} = {a * b}" if answer == a else f"{a} Ã— ? = {a * b}"

    embed.clear_fields()
    embed.add_field(name="â— Ã‰quation Ã  trou", value=question, inline=False)
    await ctx.edit(embed=embed)

    try:
        msg = await bot.wait_for("message", check=lambda m: m.author.id == get_user_id(), timeout=TIMEOUT)
        return int(msg.content) == answer
    except:
        return False

equation_trou.title = "Equation Ã  trou"
equation_trou.emoji = "â—"
equation_trou.prep_time = 0

# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# ğŸ”¹ ğŸ•’ Heures
# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
async def heures(ctx, embed, get_user_id, bot):
    h1, m1 = random.randint(0, 23), random.randint(0, 59)
    h2, m2 = random.randint(0, 23), random.randint(0, 59)
    diff = abs((h1 * 60 + m1) - (h2 * 60 + m2))
    hours, mins = divmod(diff, 60)

    heure_1, heure_2 = f"{h1:02d}:{m1:02d}", f"{h2:02d}:{m2:02d}"
    question_type = f"Quelle est la diffÃ©rence entre {heure_1} et {heure_2} ?"

    embed.clear_fields()
    embed.add_field(name="ğŸ•’ Heures", value=question_type, inline=False)
    await ctx.edit(embed=embed)

    try:
        msg = await bot.wait_for(
            "message",
            check=lambda m: m.author.id == get_user_id(),
            timeout=TIMEOUT
        )
        rep = msg.content.lower().replace("h", " ").replace(":", " ").replace("min", " ").replace("m", " ")
        nums = [int(x) for x in rep.split() if x.isdigit()]
        if len(nums) == 1:
            user_hours, user_mins = divmod(nums[0], 60)
        elif len(nums) >= 2:
            user_hours, user_mins = nums[0], nums[1]
        else:
            return False
        diff_user = user_hours * 60 + user_mins
        diff_real = hours * 60 + mins
        return abs(diff_user - diff_real) <= 1
    except:
        return False

heures.title = "Heures"
heures.emoji = "ğŸ•’"
heures.prep_time = 0

# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# ğŸ”¹ ğŸ”¢ MÃ©moire numÃ©rique
# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
async def memoire_numerique(ctx, embed, get_user_id, bot):
    sequence = [random.randint(0, 9) for _ in range(6)]
    embed.clear_fields()
    embed.add_field(name="ğŸ”¢ MÃ©moire numÃ©rique", value=str(sequence), inline=False)
    await ctx.edit(embed=embed)
    await asyncio.sleep(5)  # prep_time

    embed.clear_fields()
    embed.add_field(name="ğŸ”¢ MÃ©moire numÃ©rique", value="ğŸ•µï¸â€â™‚ï¸ Retape la sÃ©quence !", inline=False)
    await ctx.edit(embed=embed)

    try:
        msg = await bot.wait_for("message", check=lambda m: m.author.id == get_user_id(), timeout=TIMEOUT)
        return msg.content == "".join(map(str, sequence))
    except:
        return False

memoire_numerique.title = "MÃ©moire numÃ©rique"
memoire_numerique.emoji = "ğŸ”¢"
memoire_numerique.prep_time = 5

# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# ğŸ”¹ ğŸ‘ï¸ MÃ©moire visuelle (boutons)
# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
async def memoire_visuelle(ctx, embed, get_user_id, bot):
    prep_time = 4
    base_emojis = ["ğŸ", "ğŸš—", "ğŸ¶", "ğŸŒŸ", "âš½", "ğŸ²", "ğŸ’", "ğŸµ", "ğŸ•", "ğŸ±", "ğŸš€", "ğŸ"]
    shown_emojis = random.sample(base_emojis, 4)

    embed.clear_fields()
    embed.add_field(
        name="ğŸ‘ï¸ MÃ©moire visuelle",
        value=f"MÃ©morise bien ces 4 emojis :\n{' '.join(shown_emojis)}",
        inline=False
    )
    await ctx.edit(embed=embed)
    await asyncio.sleep(prep_time)

    embed.clear_fields()
    embed.add_field(
        name="ğŸ‘ï¸ MÃ©moire visuelle",
        value="ğŸ”’ Les emojis ont disparu... retrouve celui qui **n'Ã©tait PAS dans la liste !**",
        inline=False
    )
    await ctx.edit(embed=embed)
    await asyncio.sleep(1)

    all_choices = shown_emojis.copy()
    intrus = random.choice([e for e in base_emojis if e not in shown_emojis])
    all_choices.append(intrus)
    random.shuffle(all_choices)

    class EmojiView(discord.ui.View):
        def __init__(self):
            super().__init__(timeout=TIMEOUT)
            self.selected = None

    view = EmojiView()
    for e in all_choices:
        async def make_callback(emoji=e):
            async def callback(interaction: discord.Interaction):
                if interaction.user.id != get_user_id():
                    await interaction.response.send_message("ğŸš« Pas ton tour.", ephemeral=True)
                    return
                view.selected = emoji
                view.stop()
                await interaction.response.defer()
            return callback

        button = discord.ui.Button(label=e, style=discord.ButtonStyle.secondary)
        button.callback = await make_callback(e)
        view.add_item(button)

    await ctx.edit(embed=embed, view=view)
    await view.wait()
    return getattr(view, "selected", None) == intrus

memoire_visuelle.title = "MÃ©moire visuelle"
memoire_visuelle.emoji = "ğŸ‘ï¸"
memoire_visuelle.prep_time = 4

# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# ğŸ”¹ ğŸ’° Monnaie
# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
async def monnaie(ctx, embed, get_user_id, bot):
    prep_time = 2
    prix = random.randint(1, 20) + random.choice([0, 0.5, 0.2])
    donne = prix + random.choice([0.5, 1, 2])
    rendu = round(donne - prix, 2)

    embed.clear_fields()
    embed.add_field(
        name="ğŸ’° Monnaie",
        value=f"Prix : {prix:.2f} â‚¬\nPayÃ© : {donne:.2f} â‚¬\nâ¡ï¸ Quelle monnaie rends-tu ?",
        inline=False
    )
    await ctx.edit(embed=embed)
    await asyncio.sleep(prep_time)

    try:
        msg = await bot.wait_for("message", check=lambda m: m.author.id == get_user_id(), timeout=TIMEOUT)
        return abs(float(msg.content.replace(',', '.')) - rendu) < 0.01
    except:
        return False

monnaie.title = "Monnaie"
monnaie.emoji = "ğŸ’°"
monnaie.prep_time = 2

# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# ğŸ”¹ ğŸ” Mot miroir
# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
async def mot_miroir(ctx, embed, get_user_id, bot):
    prep_time = 2
    mots = ["maison", "cerveau", "banane", "ordinateur", "voiture"]
    mot = random.choice(mots)
    mot_inverse = mot[::-1]

    embed.clear_fields()
    embed.add_field(
        name="ğŸ” Mot miroir",
        value=f"Tape ce mot Ã  l'envers : {mot}",
        inline=False
    )
    await ctx.edit(embed=embed)
    await asyncio.sleep(prep_time)

    try:
        msg = await bot.wait_for("message", check=lambda m: m.author.id == get_user_id(), timeout=TIMEOUT)
        return msg.content.lower() == mot_inverse
    except:
        return False

mot_miroir.title = "Mot miroir"
mot_miroir.emoji = "ğŸ”"
mot_miroir.prep_time = 2

# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# ğŸ”¹ ğŸ§Š Ombre
# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
async def ombre(ctx, embed, get_user_id, bot):
    prep_time = 2
    emojis = ["â—¼ï¸", "â—¾", "â–ªï¸", "â¬›"]  # du plus gros au plus petit environ

    # On choisit alÃ©atoirement sâ€™il faut trouver le plus grand ou le plus petit
    mode = random.choice(["grand", "petit"])
    base = random.choice(emojis[1:3])  # symbole de base moyen
    grid_size = 4

    # On construit une grille de base
    grid = [[base for _ in range(grid_size)] for _ in range(grid_size)]

    # On remplace une case par une taille diffÃ©rente
    if mode == "grand":
        special = emojis[0]  # plus gros
    else:
        special = emojis[-1]  # plus petit
    special_pos = (random.randint(0, grid_size - 1), random.randint(0, grid_size - 1))
    grid[special_pos[0]][special_pos[1]] = special

    # Affichage de la grille dans l'embed
    grid_display = "\n".join(" ".join(row) for row in grid)
    embed.clear_fields()
    embed.add_field(name="ğŸ§Š Ombre", value=f"Trouve le carrÃ© **le plus {mode}** !", inline=False)
    embed.add_field(name="Grille :", value=grid_display, inline=False)
    await ctx.edit(embed=embed)
    await asyncio.sleep(prep_time)

    # CrÃ©ation des boutons (4x4)
    class GridView(discord.ui.View):
        def __init__(self):
            super().__init__(timeout=TIMEOUT)
            self.correct = False

    view = GridView()
    for i in range(grid_size):
        for j in range(grid_size):
            emoji = grid[i][j]
            async def make_callback(x=i, y=j):
                async def callback(interaction: discord.Interaction):
                    if interaction.user.id != get_user_id():
                        await interaction.response.send_message("ğŸš« Pas ton tour.", ephemeral=True)
                        return
                    view.correct = (x, y) == special_pos
                    view.stop()
                    await interaction.response.defer()
                return callback
            button = discord.ui.Button(label=emoji, style=discord.ButtonStyle.secondary)
            button.callback = await make_callback()
            view.add_item(button)

    await ctx.edit(embed=embed, view=view)
    await view.wait()
    return getattr(view, "correct", False)

ombre.title = "Ombre"
ombre.emoji = "ğŸ§Š"
ombre.prep_time = 2

# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# ğŸ”¹ ğŸ”¤ Pagaille
# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
async def pagaille(ctx, embed, get_user_id, bot):
    prep_time = 2
    mot = random.choice(["amour", "cerveau", "maison", "voiture", "banane"])
    melange = "".join(random.sample(mot, len(mot)))

    embed.clear_fields()
    embed.add_field(name="ğŸ”¤ Pagaille", value=f"{melange}\nâ¡ï¸ Remets les lettres dans lâ€™ordre !", inline=False)
    await ctx.edit(embed=embed)
    await asyncio.sleep(prep_time)

    try:
        msg = await bot.wait_for("message", check=lambda m: m.author.id == get_user_id(), timeout=TIMEOUT)
        return msg.content.lower() == mot
    except:
        return False

pagaille.title = "Pagaille"
pagaille.emoji = "ğŸ”¤"
pagaille.prep_time = 2

# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# ğŸ”¹ âš–ï¸ Pair ou impair
# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
async def pair_ou_impair(ctx, embed, get_user_id, bot):
    prep_time = 1.5
    nombre = random.randint(10, 99)

    embed.clear_fields()
    embed.add_field(
        name="âš–ï¸ Pair ou impair",
        value=f"Le nombre est **{nombre}**.\nâ¡ï¸ Tape `pair` ou `impair` !",
        inline=False
    )
    await ctx.edit(embed=embed)
    await asyncio.sleep(prep_time)

    try:
        msg = await bot.wait_for(
            "message",
            check=lambda m: m.author.id == get_user_id(),
            timeout=TIMEOUT
        )
        reponse = msg.content.lower().strip()
        if reponse not in ["pair", "impair"]:
            return False
        return (nombre % 2 == 0 and reponse == "pair") or (nombre % 2 == 1 and reponse == "impair")
    except:
        return False

pair_ou_impair.title = "Pair ou impair"
pair_ou_impair.emoji = "âš–ï¸"
pair_ou_impair.prep_time = 1.5

# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# ğŸ”¹ âš¡ RapiditÃ©
# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
async def rapidite(ctx, embed, get_user_id, bot):
    prep_time = 2
    nums = random.sample(range(10, 99), 5)
    mode = random.choice(["grand", "petit"])
    embed.clear_fields()
    embed.add_field(name="âš¡ RapiditÃ©", value=f"Trouve le plus {mode} : {', '.join(map(str, nums))}", inline=False)
    await ctx.edit(embed=embed)
    await asyncio.sleep(prep_time)

    correct = max(nums) if mode == "grand" else min(nums)
    try:
        msg = await bot.wait_for("message", check=lambda m: m.author.id == get_user_id(), timeout=TIMEOUT)
        return int(msg.content) == correct
    except:
        return False

rapidite.title = "RapiditÃ©"
rapidite.emoji = "âš¡"
rapidite.prep_time = 2

# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# ğŸ”¹ âš¡ RÃ©flexe couleur
# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
async def reflexe_couleur(ctx, embed, get_user_id, bot):
    prep_time = 2
    embed.clear_fields()
    embed.add_field(
        name="âš¡ RÃ©flexe couleur",
        value="Appuie sur le bouton **dÃ¨s qu'il devient vert**.\nMais pas avant ğŸ‘€",
        inline=False
    )
    await ctx.edit(embed=embed)
    await asyncio.sleep(prep_time)

    class ReflexeView(discord.ui.View):
        def __init__(self):
            super().__init__(timeout=7)
            self.clicked = False
            self.start_time = None
            self.reaction_time = None
            self.too_early = False

        @discord.ui.button(label="ğŸ”´ ATTENDS...", style=discord.ButtonStyle.danger)
        async def reflexe(self, interaction: discord.Interaction, button: discord.ui.Button):
            if interaction.user.id != get_user_id():
                await interaction.response.send_message("ğŸš« Ce nâ€™est pas ton jeu.", ephemeral=True)
                return
            if button.style == discord.ButtonStyle.danger:
                self.too_early = True
                self.clicked = True
                self.stop()
                await interaction.response.send_message("âŒ Trop tÃ´t !", ephemeral=True)
            elif button.style == discord.ButtonStyle.success:
                self.reaction_time = round(asyncio.get_event_loop().time() - self.start_time, 3)
                self.clicked = True
                self.stop()
                await interaction.response.send_message(f"âœ… RÃ©flexe en {self.reaction_time}s !", ephemeral=True)

    view = ReflexeView()
    msg = await ctx.edit(view=view)

    await asyncio.sleep(random.uniform(2, 5))
    if view.is_finished():
        return False

    button = view.children[0]
    button.label = "ğŸŸ¢ CLIQUE !"
    button.style = discord.ButtonStyle.success
    await msg.edit(view=view)
    view.start_time = asyncio.get_event_loop().time()
    await view.wait()

    if view.too_early or not view.clicked or view.reaction_time is None:
        return False
    return view.reaction_time < 1.2

reflexe_couleur.title = "RÃ©flexe couleur"
reflexe_couleur.emoji = "ğŸŸ¢"
reflexe_couleur.prep_time = 2

# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# ğŸ”¹ ğŸ§© SÃ©quence de symboles
# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
async def sequence_symboles(ctx, embed, get_user_id, bot):
    symbols = ["â­", "ğŸ", "ğŸ", "âš¡", "ğŸ²", "ğŸ€", "ğŸ±", "ğŸ”¥"]
    seq = random.sample(symbols, 4)

    embed.clear_fields()
    embed.add_field(name="ğŸ§© SÃ©quence de symboles", value="Observe bien la sÃ©quence suivante :", inline=False)
    embed.add_field(name="SÃ©quence :", value=" ".join(seq), inline=False)
    await ctx.edit(embed=embed)
    await asyncio.sleep(4)  # prep_time

    # On cache la sÃ©quence
    embed.clear_fields()
    question_type = random.choice(["position", "complete"])

    if question_type == "position":
        index = random.randint(0, len(seq) - 1)
        embed.add_field(name="ğŸ§© SÃ©quence de symboles", value=f"Quel Ã©tait le **{index+1}áµ‰** emoji ?", inline=False)
        correct_answer = seq[index]
    else:
        embed.add_field(name="ğŸ§© SÃ©quence de symboles", value="RÃ©Ã©cris la sÃ©quence complÃ¨te !", inline=False)
        correct_answer = "".join(seq)

    await ctx.edit(embed=embed)

    try:
        msg = await bot.wait_for("message", check=lambda m: m.author.id == get_user_id(), timeout=TIMEOUT)
        user_input = msg.content.replace(" ", "")
        return user_input == correct_answer or user_input == "".join(correct_answer)
    except:
        return False

sequence_symboles.title = "SÃ©quence de symboles"
sequence_symboles.emoji = "ğŸ§©"
sequence_symboles.prep_time = 4

# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# ğŸ”¹ ğŸ§© Suite alphabÃ©tique
# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
async def suite_alpha(ctx, embed, get_user_id, bot):
    prep_time = 1
    sens_normal = random.choice([True, False])

    if sens_normal:
        start = random.randint(65, 70)
        step = random.randint(1, 3)
        serie = [chr(start + i * step) for i in range(4)]
        answer = chr(start + 4 * step)
    else:
        start = random.randint(85, 90)
        step = random.randint(1, 3)
        serie = [chr(start - i * step) for i in range(4)]
        answer = chr(start - 4 * step)

    embed.clear_fields()
    embed.add_field(
        name="ğŸ§© Suite alphabÃ©tique",
        value=f"{', '.join(serie)} ... ?",
        inline=False
    )
    await ctx.edit(embed=embed)
    await asyncio.sleep(prep_time)

    try:
        msg = await bot.wait_for("message", check=lambda m: m.author.id == get_user_id(), timeout=TIMEOUT)
        return msg.content.strip().upper() == answer
    except:
        return False

suite_alpha.title = "Suite alphabÃ©tique"
suite_alpha.emoji = "ğŸ§©"
suite_alpha.prep_time = 1

# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# ğŸ”¹ â— Suite logique
# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
async def suite_logique(ctx, embed, get_user_id, bot):
    prep_time = 2
    type_suite = random.choice(["arithmÃ©tique", "gÃ©omÃ©trique", "alternÃ©e", "carrÃ©s", "fibonacci"])
    serie = []

    if type_suite == "arithmÃ©tique":
        start = random.randint(1, 10)
        step = random.randint(2, 6)
        serie = [start + i * step for i in range(5)]
    elif type_suite == "gÃ©omÃ©trique":
        start = random.randint(1, 5)
        ratio = random.randint(2, 3)
        serie = [start * (ratio ** i) for i in range(5)]
    elif type_suite == "alternÃ©e":
        start = random.randint(1, 10)
        add, sub = random.randint(2, 5), random.randint(1, 4)
        serie = [start]
        for i in range(1, 5):
            serie.append(serie[-1] + add if i % 2 == 1 else serie[-1] - sub)
    elif type_suite == "carrÃ©s":
        start = random.randint(1, 5)
        serie = [i ** 2 for i in range(start, start + 5)]
    elif type_suite == "fibonacci":
        a, b = random.randint(1, 5), random.randint(1, 5)
        serie = [a, b]
        for _ in range(3):
            serie.append(serie[-1] + serie[-2])

    answer_index = random.randint(0, 4)
    answer = serie[answer_index]
    display_serie = serie.copy()
    display_serie[answer_index] = "?"

    embed.clear_fields()
    embed.add_field(name="â— Suite logique", value=f"{display_serie} ... ?", inline=False)
    await ctx.edit(embed=embed)
    await asyncio.sleep(prep_time)

    try:
        msg = await bot.wait_for("message", check=lambda m: m.author.id == get_user_id(), timeout=TIMEOUT)
        return int(msg.content) == answer
    except:
        return False

suite_logique.title = "Suite logique"
suite_logique.emoji = "â—"
suite_logique.prep_time = 2

# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# ğŸ”¹ ğŸ” Trouver la diffÃ©rence
# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
async def trouver_difference(ctx, embed, get_user_id, bot):
    prep_time = 1
    liste1 = [random.randint(1, 9) for _ in range(6)]
    liste2 = liste1.copy()
    diff_index = random.randint(0, 5)
    liste2[diff_index] = random.randint(1, 9)
    while liste2[diff_index] == liste1[diff_index]:
        liste2[diff_index] = random.randint(1, 9)

    embed.clear_fields()
    embed.add_field(name="ğŸ” Trouver la diffÃ©rence", value=f"{liste1} vs {liste2}", inline=False)
    await ctx.edit(embed=embed)
    await asyncio.sleep(prep_time)

    try:
        msg = await bot.wait_for("message", check=lambda m: m.author.id == get_user_id(), timeout=TIMEOUT)
        return int(msg.content) == diff_index + 1
    except:
        return False

trouver_difference.title = "Trouver la diffÃ©rence"
trouver_difference.emoji = "ğŸ”"
trouver_difference.prep_time = 1

# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# ğŸ”¹ âœï¸ Typographie erreur
# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
async def typo_trap(ctx, embed, get_user_id, bot):
    prep_time = 2  # Temps pour observer le mot avant de rÃ©pondre

    mot = random.choice(["chien", "maison", "voiture", "ordinateur", "banane", "chocolat"])
    typo_index = random.randint(0, len(mot) - 1)
    mot_mod = list(mot)
    
    # GÃ©nÃ¨re une lettre diffÃ©rente de la lettre originale
    original = mot_mod[typo_index]
    nouvelle_lettre = random.choice([chr(i) for i in range(97, 123) if chr(i) != original])
    mot_mod[typo_index] = nouvelle_lettre
    mot_mod = "".join(mot_mod)

    embed.clear_fields()
    embed.add_field(
        name="âœï¸ Typographie erreur",
        value=f"{mot_mod}\nâ¡ï¸ Quelle lettre est incorrecte dans ce mot ? (ex: 'x')",
        inline=False
    )
    await ctx.edit(embed=embed)
    await asyncio.sleep(prep_time)  # temps d'observation

    # Attente de la rÃ©ponse
    try:
        msg = await bot.wait_for(
            "message",
            check=lambda m: m.author.id == get_user_id(),
            timeout=TIMEOUT
        )
        return msg.content.lower().strip() == nouvelle_lettre
    except:
        return False

typo_trap.title = "Typographie erreur"
typo_trap.emoji = "âœï¸"
typo_trap.prep_time = 2


#the end
